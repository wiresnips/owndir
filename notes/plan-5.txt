
Alright, let's back up and go over it _slowly_

	a folder has a `.central`, which is a MODULE

		BUILDING has to happen, if I want to support JSX
			- esbuild targetting node
			- save to a tempfile
			- `require` the module 
			- delete the tempfile?

	The MODULE will (one way or another) export a routes object,
		{
			['.central']: { 
				routes: { 
					[path]: { 
						get: function handlerFn (req, res, next) { /* ... */ } 
					} 
				}
			}
		}

		Where the routes object is a map of paths and handlers, 
		which will be built into a ROUTER

	ROUTER must:
		- decorate the request obect with the built module
		- respond to explicit paths with given handlers
		- pass requests that map to child routers through to them

	SERVER:
		- build the root-level router (this recurses downwards)

		MAYBE NOT CORE?
			a final catch-all route that relies on convention to simplify routes contruction down to middleware


Okay, so I need to build the module, which is how I get, eg, JSX support
	And, this has to happen BEFORE any questions about what's delivered are even raised, so we're going to be targetting node

	That seems to make sense - the built module is going to have to be run by the server to decide what to return,
	so it has to be run by the server, which means that it WILL target node.


I want to arrive at a place where my child module is basically just giving a React component,
and code merged in from the parent modules will make use of it

	Have to figure out what this means
	Do I have to re-run _everything_ on the clientside?
		(oh god, that might be what I need ...)


		Might come down to adding a route that exposes it's module as a built-for-browser js file
			and then reconstructing the context via the same merge strategy as above
			and also replicating whatever clusterfuck I end up with for plugins ...


		I need to fuck around with esbuild some more, I think ....



======================


Maybe these are two different problems, that should be separated ?
	BUILD (server-side) 
	BUNDLE (client-side)

	Eh ... I'm skeptical of that, actually
		If there are two different build processes, that means either ONE target that fits both, 
		or else TWO targets that are specified apart from each other

		And, of the two, I think the answer is clearly the second, 
		And, I think that it's the job of the MODULE to own the second part

	Okay, that's not insane, actually
		(although it doesn't get me closer to knowing the answer, either)

	Let's set BUNDLING aside for the moment, and focus on BUILDING


For sure, I want the BUILD to be something that the user can bring to the party
	For example, it'd be really nice if I could swap in ClojureScript

	But, for obvious reasons, that's not something that can be specified in the module itself
		Therefore, I'm gonna need a top-level PLUGIN (or something) that can specify how to interpret a given filetype ?

	I need to start SOMEWHERE, though - ie, I can't read the top-level module until AFTER I build it
		So clearly, it can't tell me how to build it.

		Therefore, if I want to specify an alternative build, it has to be done in a common language
		that's fair enough, I guess


okay, let's say that we have an extendable list of build mechanisms, and we roll through them in order
	
	The first one that produces output, that's our build
	And then we can have a bootstrap way of pulling in more build functions that we figure out later

		[
			// if this returns a module, then we're done
			// if it doesn't, we try the next build function
			(srcPath) => { /* */ }

		]


==================================


On the topic of BUNDLES, one of the problems that needs to be resolved is, some builds are going to output multiple files
	for example, CSS files might worm their way in


	So, what if I take control of a portion of the URL space, same as I've taken control of a portion of file-path space

		ie, I could claim `./.central/module.js` to serve the web-built module from

		So, with that in mind, what if I persist the built files for the lifetime of the server, in a parallel folder structure?


Let's leave this be for the moment


==================================


An important development happened, but was not recorded here

	1- keep BUILD output as `central.js`, in a temp directory tree that mirrors the TARGET directory tree

	2- inject `index.js` that can use `require('central.js')` AND `require('../index.js')` to wrap the parent-child merge operation
		- now, instead of manually `require`-ing each, and then merging myself, I can simply `require` the injected file which handles merge for me

		Not the final code, just a demonstration of the principle:

		```
			const central = require('./central.js')
			const parent = require('../index.js')
			module.exports = { ...parent, ...central }

		```

	3- using `Object.assign(module.exports, merged)` instead of `module.exports = {}` enables safeish circular references
		therefore, can directly require parent and child modules RIGHT HERE in index.js

		```
			fs.readdirSync(__dirname).forEach(name => {
			  try {
			    const childModule = path.resolve(__dirname, name, 'index.js')
			    if (fs.existsSync(childModule)) {
			      merged['.central'].children[name] = require(childModule)
			    }
			  } catch (err) {}
			})
		```

		THIS solves my problem of, how do I smuggle information from children up to the parent
			- just access it directly, ie 

			```
				const navlinks = [ 
					...self.navlinks,
					...self['.central'].children.flatMap(c => c.navlinks) // oughta be recursive, but this proves the point
				]
			```

	4- Now, istead of individually requiring each folder's module, I can just require the root ONCE, and I get _everything_



I THINK this can answer my browser-build inheritance issues as well - after all, can't I just re-build the root and serve that to the browser?
	
	Something to investigate a little later. Right now, I think I need to re-examine some of the other angles

		- how will plugins operate
		- how do we incorporate *directory* contents into this? (this has been thrown for a huge loop)
	

==================================

USING AN OBJECT FOR ROUTES MAKES ROUTE *ORDER* AMBIGUOUS


	Okay, so let's switch to an array of pairs


==================================



I've made a lot of progress, WRT how the modules connect to each other. How the _fuck_ am I mixing in the directory contents?

	Well ... the request is the thing, right? 

	So, let's build up a directory map like before (this time without the compile), and use the router to attach it to the request


	Okay, that's good - the NEXT thing I need to look at, then, is how to build a router
		- good, that was easy enough

		But, the reason I cared about this was, it was supposed to teach me how to get the directory information into the request

		Now, we're saying, "Inject it with middleware", and that's all well and good, but _standard_ middleware can't see that info, it's scoped to the module

		So, _this_ built-in is going to have to come from the server proper


	Aight, we can do that

==================================


	Notice also that "middleware" is totally acheivable via:

	{
		'.central': {
			routes: [
				'*': {
					all: (req, res, next) => { 
						console.log('MIDDLEWARE!')
						next()
					}
				}
			]
		}
	}


	WAIT - that's not exactly right.

		The order in which these things are given matters.

		Where do a __parent's__ `routes` rank, relative to a child?

			more specific things should take precedence over less specific, right?

			so children should have dibs on paths, which means they should come first

		BUT, this can be the distinction that we draw 
			- middleware can be BEFORE children, 
			- routes can be AFTER children



==================================


Hmmm

	I notice that my routers have no knowledge of the contents of the directory, or even of the name of their OWN directory

	I can put things into the request, but something's not quite right here

	Maybe I want to make it more directly available, right?


		--------
		There's a weak connection to the naming issue I've been having this whole time

			what DOES 'central', the noun, refer to?
				- the system as a whole?
				- the user's instance of the system
				- the code that the user has written for themselves, and the modules that they're exporting
				- the keyspace carveout that I've made for myself, ['.central'], and THAT code?

			This might matter a *lot* in terms of making the system teachable

			Maybe I should rename ['.central'] to ['.system'] or something ...
				or, fragment it out into different keys?
					['.router']
					['.module']
					['.directory']
		--------

	Okay, hold on - because I've got this whole quasi-inheritance thing going on, things aren't quite as they seem


	the SCOPE of a function written in `./.central/index.jsx`, is going to be the contents of that file
		when I BUILD that, it'll become `central.js`
		and then the MERGE will happen in `index.js`

		the MODULE that's output from there is what I'm using as the unit of work

		BUT IT IS NOT THE SAME AS THE SCOPE OF THE FUNCTION

	I *NEED* to use the router to pass the fully-assembled module in to itself
		at least, if I want to have access to any of that fancy shit I'm adding ...


	Still don't think that this is going to actually _solve_ the problem, though

	How can I get a function in the parent to call a function in the child?


	MAYBE I can do some bullshit with getters and setters in the assets/index.js ?
		Can I put a getter on a scope?

		-----------

			Lol nope. Javascript has _lexical_ scoping, 
				of course, I knew this if I'd stopped to consider it
				but, I knew that I'd run into this kind of problem

				for a refresher, see: https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53

				```
					let number = 42;
					function printNumber() {
					  console.log(number);
					}

					function log() {
					  let number = 54;
					  printNumber();
					}

					log(); // Prints 42, because duh-doy
				```

				So, when I'm fucking around with `with`, I'm basically doing THAT, and getting disappointed when it doesn't print 54

		---------


	So, if I want to run child code, I have to run it FROM THE CHILD

		The child has the parent in it's prototype chain, but the handler has to be on IT's router if I want IT's code to be used in the rendering
