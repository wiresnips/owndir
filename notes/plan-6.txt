Alright, let's think about PLUGINS


First thought, plugins are functions that transform modules


	function plugin (_module) {
		// this isn't how middleware works (yet), but you get the idea
		_module['.central'].middleware.push((req) => {

		})

		return _module
	}


Which certainly seems like it would be powerful enough





I need to resolve the tension between my inheritance model, and how plugins work

	- do plugins only run WHERE there are installed? Or do are they applied in a downstream cascade?

		If they're applied in a downstream cascade, that would kinda obviate the inheritance, wouldn't it?
		or at least, it *could* obviate the inheritance, depending on the order of application

	- the fact that *routes* cannot be meaningfully inherited is problematic
		I can put a catchall route on a node, and it'll work, but it'll always run AS THAT NODE





Okay, so maybe the way to resolve this is to think in a slightly more detailed way about what I actually want TO DO with these systems ...

	PLUGINS and INHERITANCE are two different ways of adding functionality to a module without writing it in directly



1- I want a plugin to be able to add a function to a module
2- I want a plugin to be able to add a *route* to a module



Okay, no - this isn't confusion about plugins, this is confusion about ROUTES

	I need a way to create a catch-all route that will be handled at the BOTTOM of the traversal, instead of bubbling all the way back up to the TOP

	And, inheritance isn't going to do that for me, because ROUTES ARE NOT INHERITTED


	Another way I could go is, I could just create a utility function to simulate nearest-node for catchall routes
		ie, that walks through the children with the request

		Is that it? was that the whole tension? 
			kinda think it might have been ...



Okay, let's think about plugin DEPENDENCIES

	I thoroughly expect plugins to get intertwined with each other, after all

	On the other hand, I REFUSE to build a shitty-ass package-manager - there can _maybe_ be one in some kind of meta-client, but I'm sure as shit not building one at the base layer. Manage that shit yourself.

	So, I think we're landing on, NOPE

		I will not manage your plugin dependencies (yet)
		That shit is on you.








Okay, let's think about FRAMES, in the context of PLUGINS

	let's imagine a plugin that handles markdown

		const callAsNearestNode = require('call-as-nearest-node')

		module.exports = function (context) {
			context.renderMarkdown = renderMarkdown

			context['.central'].routes.push(
				['*.md', ['get', 
					function (req, res, next) {
						return callAsNearestNode(req, this, function () {
							if (!req.file) {
								next();
								return;
							}

							// okay, so HERE we can see the problem that we've run into
							// IF I had wanted to wrap this content in some kind of frame (ie with a navbar and so forth)
							// I would need to know about that HERE

							// like, even something along the lines of, the CSS to apply to the markdown, 
							// how is that going to find it's way into the output?

							// and that pushes decisions and knowledge into the markdown plugin, that I don't think belong there


							res.send(this.renderMarkdown(req.file))
						}
					)}
				]]
			)
		}

		function renderMarkdown (fileNode) { ... }




	So, what can I do about this?

		I *almost* want to start modifying express with outbound middleware
			IE, shimming `request.send` so that I can slip my frame in at that layer

			this feels like *very* bad road, though ... 
			Yeah, to go down this road, I have to almost entirely abandon Express


		Okay, so the next answer is, CONVENTION
			IE, start making some actual fucking decisions about how this framework is going to function

			but, I would prefer not to?


		WAIT WAIT WAIT

			http://expressjs.com/en/api.html#res.render
				> `res.render(view [, locals] [, callback])`
				> Renders a view and sends the rendered HTML string to the client.

			WTF is a view?

				> The view argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the views setting. If the path does not contain a file extension, then the view engine setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via require()) and render it using the loaded moduleâ€™s __express function.


				> A template engine enables you to use static template files in your application. At runtime, the template engine replaces variables in a template file with actual values, and transforms the template into an HTML file sent to the client. This approach makes it easier to design an HTML page.

			THIS sounds like something that I can shim a FRAME into ... not that I want to use static files (I actually kinda don't), but it's a gateway to post-processing (ie, wrapping whatever's rendered in some kind of FRAME) that might leave Express intact...


			http://expressjs.com/en/advanced/developing-template-engines.html

			app.engine(
				'ext', // file extension
				function (filepath, options, done) {

					// filepath appears to be absolute: `resolve(root, name)`
					//		where NAME is `render`'s first argument, and ROOT is set via `app.set('views', './some/root/dir')`

					// options appears to be `render`'s second argument (or an empty object)

					// done appears to be EITHER render's third arg, OR a default function
					//		expects to be called, `done(error, renderedString)`,
					// 		if error, calls `next(error)`, otherwise calls `res.send(renderedString)`


					// okay, so I fuck around, do whatever I want, I build renderedString (or error trying), and then I call `done`
					return done(error, renderedString)
				}
			)


			AND AND AND

			I can include MIDDLEWARE that will wrap the response's render function, so that the first argument, for the filename, is optional - how's THAT sound?
				sound pretty good, me. Sounds like exactly what I wanted to do.





So, with all that set up, how the _fuck_ am I going to do web build?

	1- this is not a whole new plugin ecosystem - this is one line that I build directly
		(because I can recompile the built code, I don't need to enable custom build here)

	2- this is going to require totally folding the DIRECTORY node into the built code. FUCK.

		Because I can't use the filepath and fs to get it, when it's going to 