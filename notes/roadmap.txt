
Let's think a little about build and sync
=========================================
	
	I am not (any time soon) going to worry about re-bundling when code changes.
	this is an edge that I do not care about

	when a folder is added, it should be granted a new OwnDir
		- this should be a clone of the parent
		- including plugins

	I notice that I'm not actually making much use of hte irectory-based constructors
		Can I make any big wins, if I ditch them entirely?



mapDir, permissions, fsNode_server test rig
============================================




webDAV
======
	what the fuck is this? I went looking for things like this before, but didn't find them.
	well, there it is.

	Do I want it?
	Interface sure _looks_ like what I'm building, doesn't it?

	Does this kind of interop actually _help_ me?
	what does it buy?

		- interoperability with existing systems
			- I can use this to write out files ELSEWHERE
				might actually be useful ...
			- external systems can read and write me
				- I think this is a downside?

		- probably just a better API than I've built?

		- how do permissions work?
			looks like this is a fact about the specific backend, rather than a fact about the protocol
			which, yeah, that makes sense
			So, I CAN have permissions, but I also have to actually do it.
			AND, it'll require me to integrate with a specific webDAV server
			or, I guess, implement my own ...

	I think this is mostly orthogonal to me?
	but, my better judgement is whispering that I should integrate it anyways ...

	the neat thing is, the API that I've mapped is a fairly good match
		- this is pretty validating; I'm probably not that off where I need to be
		- maybe this means I should switch over? Or that I should switch over SOMETIME?
		- or, maybe it just means that I can pump it the other way later

Basic summary of my thoughts:
	- webDAV is NOT a drop-in solution
		need to get a client, need to get a server, need to integrate BOTH of them
		need to reconcile auth and permissions, lots of open questions
		need to reconsider the fundamental nature of fsNode
		would still want to put an interface over it

	- but also, the interface is _very_ close, capability-wise
		If saying no is a mistake, I think it's a _recoverable_ mistake
		should also be able to go the other direction, offer webDAV integration with a plugin

	- the interesting-sounding extensions of webDAV are just "pass this shitty fileformat using the protocol"
		calDAV: calendar events, cardDAV: contacts - these clearly aren't meant to be human-friendly
		it's still data under your control, so it meets the spirit
		but it doesn't allow the naked text to BE the interface, in the way I really want
			so, I probably wouldn't personally use it directly

	- I also kinda don't want to prioritize third-party access
		it'd be nice for letting things integrate, but that needs to be done MINDFULLY
		like, if I just "implement calDAV", so that google calendar can export events to me,
			WHERE DO THEY END UP?
		obviously, that's a question that the integration has to answer,
			BUT, the answer doesn't belong at this level
			any stupid calendar thing that I end up building, will exist outside of my filesystem interface

With all of that, I think I'm NOT going to integrate webDAV at this point.




Rethinking Fundamentals
=======================
	it might be time to move back away from constructor functions

		would actually neaten a lot of fiddly bits that've cropped up recently
			ie, relocating existing owndirs in the tree, becomes possible again

		Also, now that I've ironed out my build system, and my ABSENCE of a templating system,
		the lifecycle question (which the constructors were meant to answer) has entirely dissolved.

			I think the only thing that really came out of that was the "addRoute" function,
			and that works _just_ as well as an import. I still need a setup to handle my own imports,
			but that's neither here nor there.

			well .. there's also the question of when to set directory permissions
			that might be the REAL thing that came out of that, actually ...
				no reason that can't be handled just like routes, though

		I don't need to do this now, though
		this will be relevant when I get around to re-evaluating fsNode listeners


There's a lot to do, but I need to keep myself coming back to it
So, let's ask a very simple question - what do I WANT to do next?


What do I want to do next?
==========================

	kinda want to lay out some of my own landing page, maybe?

	Yeah, let's shelve the tree-layout for now
		(I don't really feel like cloning obsidian today)

	Instead, I can just fuck around a little with the bankey type stuff,
		this cuts back towards the original goal


----------

I don't think I can seriously work on any of that yet
I've got a thirty-fucking-second build time, every time I make changes, because I'm uselessly redownloading packages

	okay - this is because owndir disagrees with what's in the cache, but it's also not updating package-lock ... ?
	I still don't feel like I understand this - shouldn't that be a one-time cost as I stomp the out-of-sync packages?

	BUT! I can force a re-sync by running `cleanup`, so that's at least _something_
		let's see if we can learn more next time we drift out of sync with the rest of the world

-----------


Reminders
=========
	
	I don't have to optimize the availability of actions that I don't really care about

		consider `fsNode.move`
			this is a VERY limited, compared to `mv`
			for example, consider moving all pngs into a folder
				`mv *.png my-pngs`
			there's no one-call way to do this with fsNode
				`fsNode.childrenArray.filter(c => c.name.endsWith('.png')).forEach(c => c.move('../my-pngs'))`

		And, _maybe_ that matters, right?
			there's actually a questionable decision here, where things done _to_ a path, must be done _from_ the path
			I might actually reconsider this whole aspect of the interface

		OWNDIR IS NOT A SHELL. OWNDIR IS NOT A FILE MANAGER.
			I want it to be _possible_ to manage files, because those _capabilities_ matter
			but they are not (yet) important in and of themselves
		
		this "weakness" (difference?) in my interface, while it's worth thinking about.
		is absolutely NOT worth dwelling on (yet)

		I'm probably going to end up applying a similar sort of logic to event-listeners
			although, I think I might care a little more about those



auth layer in front
===================
	currently, directory access routes preempt owndir routes
	therefore, it's impossible to create a gatekeeper from inside the system

	this is easy enough to solve by adding another routing layer in front of directories


File Change Events
==================

	these are just kinda fuckey no matter how I slice it
		REALLY not happy with the handwave I have in the direction of listeners

	needs a built-in client-side solution



Permissions
===========
	these probably just don't work at all
		needs RIGOROUS validation

	currently, permissions hinge around fsNodes, and not paths
		- this means that I can use predicate functions (instead of just paths!)
		- if a file doesn't exist yet, I cannot ask whether or not I have write permission

	IF A FILE DOES NOT YET EXIST, I CANNOT ASK WHETHER IT CAN BE CREATED
		it was worth repeating this one, at volume
		this one NEEDS a solution

	AoE permission checks are _terrible_
		children's permissions preempt their parent, ie:
			parent: ["children are read-only"]
				child: ["you can write me"] <= READ AND WRITE
		
		if children don't specify anything, parent rules come into play, ie:
			parent: ["children are read-only"]
				child: [] 					<= READ ONLY

		suppose we want to delete a directory
		to do that, we need write-permission on EVERY DESCENDANT of the directory
		but, because parent rules can target particular children, each child has to check individually with it's parents
			(AND MAYBE THIS IS THE PROBLEM)

		imagine we delete a directory that contains foo/node_modules (likely containing thousands of files)
			every single child needs to check individually whether or not _it_ can be written, AND whether or not it's PARENT says it can be written

		which is absurd, right? that's clearly stupid

		On the _other_ hand, maybe it's okay for this to be costly, right?
			If large scans are infrequent, they might be appropriate.
			Under what circumstances will bulk permissions be required?




Loose Ends
==========

	fsNode functions should never leave the fsNode tree

	if a folder gets pasted in:
		I rely on the events being delivered in a top-down order
			if they were delivered randomly, I would just _die_
			not sure if I can learn whether or not this is a problem by inspecting chokidar's code?
				might need to inspect *platform* code, which is ... well it's a lot

		I have no mechanism to cascade the existing owndir
			probably I just crash? Something to test later

	hardcoded client.js path

	solution to bundling fsNode_client.js
		once I get around to experimenting with a plugin-distribution mechanism, 
		maybe this will get folded into that?

	there might be some shenanigans WRT windows vs posix paths, ie foo/bar/baz vs foo\bar\baz
		because a lot of this shit runs server-side AND client-side, consider normalizing paths to posix
		this might entail replacing `require('path')` with `require('path').posix` everywhere

	fsNode.write args are a trainwreck




actually working with react is proving unexpectedly painful
===========================================================

	I think, what I'm learning is that I can't just expect things to _work_ on arbitrary terms

	SSR is different from CSR, (and probably React is different from SolidJs),
	and I can't expect things that work well in one to carry across smoothly to another
		and, crucially, it looks like I'm not going to be able to paper over the difference with the build

		So, let's think about what adaptations will be required:

			React-SSR
				- some utility-functions to smuggle in event handlers, maybe

			React-CSR
				- don't make your components async by default

		Alright, that's actually a reasonable answer. I don't _love_ it, but it makes perfect sense.

		For now, just focus in on React-CSR
			I'm happy enough with the _reach_ of the build system, so we can prove out alternatives later


how to deal with static assets?
===============================

	I want some easy way for plugins to declare, and then make use of, static assets

	this might also need to adapt, depending on 


crashes and failed compilation
==============================

	I must be able to detect these, right?

	Maybe I need to start fucking around with Babel directly
	


plugin distribution mechanism
=============================
	a postinstall script that moves the plugin from node_modules up a level

	then, you can `npm install @homestead/fancy-plugin`, and it'll just work, I think ...

	can I get this working cross-platform?
		the way to do this is, to use javascript instead of bash

		so, let's imagine a package, @homestead/plugin-utils
		plugins can require it, and it will provide a postinstall.js script

		then, in package.json, you have this:
			"postinstall": "node node_modules/homestead-plugin-utils/postinstall.js my-plugin"



Android?
========



HTML diff and patch for SSR bundles
===================================

	this seems like it should be a solved problem, right?
	there must be some existing solution to merge a DOM node into an existing DOM node

	checkout jQuery.load(), this is like 90% of what I care about
	and it's deliciously braindead

		https://api.jquery.com/load/
