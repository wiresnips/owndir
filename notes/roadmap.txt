
Npm Cache Issues
================
	- see: notes/yarn-test
	- see: https://github.com/yarnpkg/yarn/issues/2165
		- with yarn, using "link:" instead of "file:" works, AND doesn't require packing into tarballs
		- maybe that works with npm as well?
				NOPE: npm install error Error: Unsupported URL Type "link:"

			this is actually pretty huge progress. 
			I don't love that I'm manually including plugins that seem like they ought to be defaults, but it's still _way_ better



FsNode Refactor
===============

	permissions
		- stubbed for now, cirle back later

	I need to figure out how the hell fsNodes and owndirs relate to ROUTERS
		when rendering SSR, it's VITAL that the handler have SOME access to the owndir, and the fsNode
			- how the fuck else is it going to get access to: code, things to run code on?
			- as long as there's a link between them, this can be either or both
			- maybe don't even need the link?

		when rendering CSR, routers barely exist except as a gateway to the fsNode
			or, maybe this is just an evolution in how I'm using the framework?

	It's actually _really_ useful to have access to a synchronous list of children,
	when the view is going to be informed by them

		wow, that's not even a little bit compatible with the way I'm handling fsnodes right now
		not really a problem for OWNDIR nodes, though - those are all built ahead-of-time

			well... okay - that KINDA works ...
			BUT - it doesn't maintain the two-way binding to the FsNode


	Maybe routers move back to OwnDir, instead of FsNode?
		dammit, I really want to marry these interfaces
			actually, it might be time for that
		
		suppose that we move the lightweight FsNode (proxy.js) infra INSIDE owndir-prefix-2.js
			- OwnDir knows the root, no need to pass it in
			- need to pass in the FsNode INTERFACE, but that's _very_ doable
			- easy bidirectional links between fsNode and owndir
			- owndir is the site of routing (again)



build to a local cache, NOT <path>/.owndir/build/
=================================================

	that shit shouldn't be shared between users


webDAV
======
	what the fuck is this? I went looking for things like this before, but didn't find them.
	well, there it is.

	Do I want it?
	Interface sure _looks_ like what I'm building, doesn't it?

	Does this kind of interop actually _help_ me?
	what does it buy?

		- interoperability with existing systems
			- I can use this to write out files ELSEWHERE
				might actually be useful ...
			- external systems can read and write me
				- I think this is a downside?

		- probably just a better API than I've built?
			- I mean, it kinda _is_ the api that I've built

		- how do permissions work?
			looks like this is a fact about the specific backend, rather than a fact about the protocol
			which, yeah, that makes sense
			So, I CAN have permissions, but I also have to actually do it.
			AND, it'll require me to integrate with a specific webDAV server
			or, I guess, implement my own ...

	I think this is mostly orthogonal to me?
	but, my better judgement is whispering that I should integrate it anyways ...

	the neat thing is, the API that I've mapped is a fairly good match
		- this is pretty validating; I'm probably not that off where I need to be
		- maybe this means I should switch over? Or that I should switch over SOMETIME?
		- or, maybe it just means that I can pump it the other way later

Basic summary of my thoughts:
	- webDAV is NOT a drop-in solution
		need to get a client, need to get a server, need to integrate BOTH of them
		need to reconcile auth and permissions, lots of open questions
		need to reconsider the fundamental nature of fsNode
		would still want to put an interface over it

	- but also, the interface is _very_ close, capability-wise
		If saying no is a mistake, I think it's a _recoverable_ mistake
		should also be able to go the other direction, offer webDAV integration with a plugin

	- the interesting-sounding extensions of webDAV are just "pass this shitty fileformat using the protocol"
		calDAV: calendar events, cardDAV: contacts - these clearly aren't meant to be human-friendly
		it's still data under your control, so it meets the spirit
		but it doesn't allow the naked text to BE the interface, in the way I really want
			so, I probably wouldn't personally use it directly

	- I also kinda don't want to prioritize third-party access
		it'd be nice for letting things integrate, but that needs to be done MINDFULLY
		like, if I just "implement calDAV", so that google calendar can export events to me,
			WHERE DO THEY END UP?
		obviously, that's a question that the integration has to answer,
			BUT, the answer doesn't belong at this level
			any stupid calendar thing that I end up building, will exist outside of my filesystem interface

With all of that, I think I'm NOT going to integrate webDAV at this point.




There's a lot to do, but I need to keep myself coming back to it
So, let's ask a very simple question - what do I WANT to do next?


What do I want to do next?
==========================

	kinda want to lay out some of my own landing page, maybe?

	Yeah, let's shelve the tree-layout for now
		(I don't really feel like cloning obsidian today)

	Instead, I can just fuck around a little with the bankey type stuff,
		this cuts back towards the original goal






File Change Events
==================

	these are just kinda fuckey no matter how I slice it
		REALLY not happy with the handwave I have in the direction of listeners

	needs a built-in client-side solution






Loose Ends
==========

	hardcoded client.js path

	solution to bundling fsNode_client.js
		once I get around to experimenting with a plugin-distribution mechanism, 
		maybe this will get folded into that?

	there might be some shenanigans WRT windows vs posix paths, ie foo/bar/baz vs foo\bar\baz
		because a lot of this shit runs server-side AND client-side, consider normalizing paths to posix
		this might entail replacing `require('path')` with `require('path').posix` everywhere


how to deal with static assets?
===============================

	I want some easy way for plugins to declare, and then make use of, static assets
	whadaya wanna bet this flows through FsNode somehow?


crashes and failed compilation
==============================

	I must be able to detect these, right?

	Maybe I need to start fucking around with Babel directly
	


plugin distribution mechanism
=============================
	a postinstall script that moves the plugin from node_modules up a level

	then, you can `npm install @homestead/fancy-plugin`, and it'll just work, I think ...

	can I get this working cross-platform?
		the way to do this is, to use javascript instead of bash

		so, let's imagine a package, @homestead/plugin-utils
		plugins can require it, and it will provide a postinstall.js script

		then, in package.json, you have this:
			"postinstall": "node node_modules/homestead-plugin-utils/postinstall.js my-plugin"



Android?
========



HTML diff and patch for SSR bundles
===================================

	this seems like it should be a solved problem, right?
	there must be some existing solution to merge a DOM node into an existing DOM node

	checkout jQuery.load(), this is like 90% of what I care about
	and it's deliciously braindead

		https://api.jquery.com/load/
