

for scheduling?
	https://github.com/breejs/bree



=============








this is starting to come together, but I'm not convinced that it's all the way there ....


I know that I'm going to use JSX as my templating, that was a good pickup

I know that I'm going to evaluate a blob of javascript, and take it's `exports` as a value 










Let's think about context/environment

	If we say that each 'central' receives a _context_ from above, and _returns_ a context which is passed down, that gets me somewhere ...

	I can define things almost as middleware ....





So, let's say that our context is a map, with arbitrary keys
	
	{
		html: (context) => (),
	}



Now, we start at the root directory, and we execute .central with an empty map as input

	then, for each child, we take the result of that and execute the child's .central with the paren't output








Okay, but what happens with the result of that recursive build?
I've moved through my directory, and I've got an object (of some sort) for each path that I care about


NOW I want to SERVE the damned thing, right?





So, I need to take that list of paths (ie, the directories that had a .central in them), and create a ROUTE using the object 
	well, the stupidest possible thing would be if the context just contained a bunch of handlers, right?


	// an example of how to locate a router at a path: https://gist.github.com/zcaceres/f38b208a492e4dcd45f487638eff716c
	const express = require('express')

	function contextRouter (app, context) {

		const router = express.Router();


		// if there are no explicit routes, convert the thing we DO have into some ...
		// there's surely a graceful way to uplift whatever degenerate thing is the default, after all
		// not literally this, but something like it ...
		if (!_.has(context, '.routes')) {
			context = { ['.routes']: {['/']: { get: context } } }
		}


		_.toPairs(context['.routes']).forEach(([path, handlers]) => {

			// if it's just a function, make it a get handler
			if (_.isFunction(handlers)) {
				handlers = {
					get: handlers
				}
			}

			// any handlers we have, add to the router
			const {get, put, post, patch, delete} = handlers
			get && router.get(path, get)
			put && router.put(path, put)
			post && router.post(path, post)
			patch && router.patch(path, patch)
			delete && router.delete(path, delete)
		})

		return router
	}



Okay, that's about the right flavour of stupid


Then, the missing sauce would be, how do I quietly do the right thing with some simpler examples?
	this is a whole-ass web app, which isn't really what I'm looking for in a TYPICAL case







Okay, so what's a typical case, really?


	Well, I've got this notion that the context is the basis for templating, right?
	Like, I can call 

		context.html(context)

	and it'll render out a web page
		- most values having been established further out, and child pages subbing in just the bits that they need



	so, in order to convert that to a route-handler, I would want something like this:

		{['.routes']: {
			['/']: {
				get: (req, res) => res.send(context.html(context))
			}
		}}







I want to think a little more about this. Let's think about MARKDOWN, which is a pretty basic usecase, right?


	So, for a folder expected to contain one or more markdown files, I might have something like this:


		// https://github.com/markdown-it/markdown-it
		const renderMarkdown = (new (require('markdown-it'))()).render

		export function articles (context) {

			// this needs finangling around how exactly I'll get the files, 
			// but I'm thinking that I provide a map with some metadata, and a *function* that will pull the body
			// RETHINK THIS SPEC LATER ON

			return = context['.dir'].files
						.sort((a, b) => a.path.localeCompare(b.path)) // https://stackoverflow.com/questions/51165/how-to-sort-strings-in-javascript
						.filter(({path}) => path.endsWith('.md'))
						.map(({read}) => read()) 					  // NOT FINAL INTERFACE
						.map(renderMarkdown)
		}


	And put that in a context where the root is going to expect `articles` to exist when it calls `html(context)`














Okay, so with that in place, what do I still need?


	- I need to specify some parts of the context object
		- what datastructures will I INJECT, to be consumed by the .central customizations?
		- what values will I INTERPRET, that should be RETURNED by the .central customizations?


	- I need to somehow bridge the gap between my router-specification and whatever-my-output-is
		- some kind of specifiable middleware?


	- I need to think about how to do vertical features like search
		- perhaps, just allowing the top-level to see into their children is enough?


	- open questions:
		- realtime vs cached?
		- built-in scheduler?
		- how to access static files?
		- middleware plugins?








I've lost a thread with the jump to expecting routers
	
	before, I expected to call a function that would cough out some html
	and I was going to pass in a loosely-defined "context" 



I've also missed a beat in the notion of the modules ... 
How exactly am I expecting the overloads to happen if I'm just treating them as maps?

	Yeah, this is a BIG issue with my approach





Hang on, these two are actually the answer to each other

	Modules are closures (at least, they sure look like closures)
	I can override values of module.export, but inside the module, that's not what's being used as a lookup table

	For example, I built this simple test rig without thinking too hard about what was going on:


		const reqStr = require('require-from-string')

		let m1 = reqStr(`module.exports = {
				f: () => 'calling g(): ' + g(),
				g: () => 'base'
			}
		`)

		let m2 = reqStr(`
			module.exports = {
				g: () => 'overload'
			}
		`)

		m1.f()


	and it IMMEDIATELY failed, because in m1, g IS NOT ACTUALLY DEFINED
		because obviously, because that's how it's ALWAYS WORKED


	What this means is, I can't naively merge modules into each other and expect them to override each other's functions 


So, if I want a module to have overridable 'slots', I need to explicitly ask some kind of context to give them to me

	
	export function html (context) {


		// oooh, I kinda like this
		const {directory, routes} = context['.central']



		const { headItems, sidebarItems, main } = context
		// const { headItems, sidebarItems, main } = context.central
		// const { headItems, sidebarItems, main } = context['.central']


		return <>
			<head>
				<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåê</text></svg>">
				
				<!-- also need to think about _accumulating_ values -->
				{ headItems }
			</head>

			<body>

				<header />

				<sidebar comment="assume this component has been defined elsewhere">
					{sidebarItems}
				</sidebar>

				<nav />

				<main />

			</body>
		</>
	}



Okay, that's not insane - so the merged module will BE the context ... 
	How do I map that back into the router?




Well, let's have a look at taking apart the request
There was a notion that we could just use nested routers, but that doesn't really jibe with symlinks bullshit ... 




app.all('*', (req, res) => {


	
	
})




====================================================


It looks like there's no way to remove routes after the app's started, 
and no way to add routes anywhere but the end (which means I can't use the default route to inject new routes higher in the priority list)

	https://github.com/expressjs/express/issues/2596


https://stackoverflow.com/questions/31632763/how-does-express-know-which-router-path-to-use-when-multiple-paths-match

	It seems like I could make the FIRST route

		app.all('*' (req, res, next) => { ... })

	and then use that to create new, matching routes on the fly,
	which will go lower in the stack,
	and then call 'next' on them to let them fall down into the new route ...

	This isn't that far from just building my own router, though ...

	Like, at some point I should EITHER do that, OR abandon loops altogether




So, what if I go in for static generation, then?
	- drop out of loops
	- allow multiple paths to the "same place"
	- aggregate modules at build time



--------


wait, shit

	a router is just a function, you can call it:

		app.all('*', (req, res, next) => {
			yourFancyRouter(req, res, next)
		}	

	

	Okay, that's a reasonable answer to the first half of my dynamic routing problem

	if I want middleware to cascade correctly 
		(I'm assuming that I'll figure out how to incorporate middleware at some point)

	then it'd be convenient to actually have the routers `use` each other

	Presumably, then, I can cascade this all the way down? Yeah, that sounds about right ....




Okay, let's think about MIDDLEWARE

	Keeping in mind that middleware is really just more routes

	Well, I definitely need pre- and post- routes
		Ie, routes that go ahead of the children in the stack, and routes that go after






=======================================================



No, I need to think about the linkage between the routes and the HTML.

	I started looking at middleware, and compiling modules, and there's a whole THING down that rabbithole,

	but what I _really_ need is to understand how I'm going to decide what to return when my route gets called