PLUGINS

	I've been thinking that I want a folder called 'plugins' that would contain code, but that's INCREDIBLY dumb

	what I _actually_ want is a specialized attribute, `['.central'].plugins` or something, that takes an ARRAY OF FUNCTIONS

	and then those functions can just be required in the usual way


	EXCELLENT


	And then, ideally, instead of passing functions through as a list, it'd be recursively layered somehow ... 




===============



It's been a couple of weeks, I'm not _quite_ sure I understand how I thought that plugins would work


So, we've got the idea that each .central is a little webapp

	{
		['.central']: {
			routes: {
				['/']: {
					get: (req, res) => res.text('lol, butts')
				}}}}



Okay, this is cute enough, but I need connective tissue on _either_ side

Let's look at markdown as an example

	I want a route that will, for any `*.md` file in the folder, show the rendered markdown



	{
		['.central']: {
			routes: {
				['/*.md']: {
					get: (req, res) => {

						const {context} = req;
						const target = req.path.substring(1) // remove the leading '/'
						const { path } = context.children[filename]

						const markdown = fs.readFileSync(path, 'utf8')
						const html = processMarkdown(markdown) // whatever the actual function call is

						// alright, now NOW I've got a problem, because I want to somehow put this into a _frame_, right?

					}}}}}



=============================


So, I've got this whole-ass router in some child directory, that seems fine

IF this is how we do things, then the router has to return the webpage, right?
	The _broadest_ way to handle that would be to add the context to the request, it can carry the frame down from above, BUT

This is one of my central tensions - if I'm going to PASS DOWN a render method from the outer layers,
then that's going to create a necessary coupling across the layers

or, another way - let's imagine two instances of central (A and B), built independantly
	they look different, they work differently under the hood (because everything is just a router, could be anything)

	if I copy a folder from A into B, do I expect it to _just work_ ?

		it's _possible_, but it can never be a GUARANTEE


Okay, cool - so we *need* to separate the question of how things are routed from the question of how things are rendered

This is going to impact plugin interoperability, so it _might_ be worth applying some structural pressure to force a standard solution ...


So, let's think about _some_ solution ...

	well, if the final html structure is going to be driven from outside, but called from inside, then I need something to call ... let's call it 'render'

	now, I could explicitly pass arguments, but it's going to be attached to the context object anyways


	so, what I probably want is something like this:

	{
		['.central']: {
			routes: {
				['foo']: {
					get: (req, res) => {
						const {context} = req
						context.main = mainRenderFn // ie, a react component
						context.render()
					}}}}}


	// and then, actually, there's no reason that I couldn't put the final call to "render" in a catchall route at the bottom, right?


	So then, my route could look like this:

	{
		['.central']: {
			routes: {
				['foo']: {
					get: ({context}) => {
						context.main = mainRenderFn // ie, a react component
					}}}}}


	and then somewhere else, all the way at the root, I can have this:

	app.use((req, res) => {
		req.context.render(req.context)
	});


	Okay, this looks GOOD

	my routes can just extend the context, and we can push sorting it out into the render call at the end

=============================


Okay, so let's look at something else - how can I push information UP the directory tree?

	One answer is, don't - just hardcode some links if you want to, and put them in the root

	Honestly, I think that's fine? The whole point of this is to make it easy to manipulate the UI, right?

	Downside, it introduces couplings that have to be maintained

The _other_ way would be, a preliminary pass in the root, that scans downstream centrals for specific attrs, which ... yeah, that's totally kosher

	And, it could probably even be it's own plugin


==============================

I think it's time to try actually building something?

Need to think more about how contexts and compilation work, but it might be time for a concrete example



Okay, yeah, I DEFINITELY need to unwind the static generation vs ... non-static generation? question 



Well ... if I want interactivity to be possible, I need to get the context to the client somehow, right?

And, if the context includes CODE (which, yeah) then it needs to be bundled, right?

	(possibly excluding the protected context['.central'], which is the server itself)


Okay, so if I need to bundle it, then I need some webpack, don't I? Or at least something like it



==============================



Alright, so let's say that I _like_ esbuild for the moment

What does that mean? - I'm going to build each .central with it ... okay - that gets saved in a directory someplace, and now the JSX is processed

	THIS is what my "compile" should have been. Once I've done that, I can require the module, and merge the parent into it.

	The output of _this_ is my `.central`

	Which is to say, this is my local router (via `.routes`)

	Which is to say, how to decide _what_ to send to the browser is a problem to be solved INSIDE this layer

		something something plugins

BUT, it also means that I can get this layer right, and THEN decide how to handle plugins and middleware AFTERWARDS



==============================


Okay, so that seems to resemble a build, but .... fuck, I don't have enough mental figers to hold all the pieces in my head at once




