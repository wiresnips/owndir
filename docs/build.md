
Build takes place in a staging folder at `<server-dir>/build/<hash>/`, outlined below. The particulars aren't _that_ important, but I think it's helpful as an outline of the moving parts of the process.

```
build/ 
  <hash>/      # staging area for the build of the whole owndir directory tree
    package/     # package exposing the Assembled `.owndir` code
    client/      # copied here from /.owndir/build/client
      bundler/     # bundles client/package into a single `dist.js`
      package/     # provides a client-side entrypoint (ie, attaches a react app into the DOM, connects FsNode interface to the server)
      dist.js      # the final client bundle, generated by client/bundler
    server/      # copied here from /.owndir/build/server
      bundler/     # bundles server/package into a single `dist.js`
      package/     # provides a server-side entrypoint (ie, exposes FsNode interface, serves custom routes, etc)
      dist.js      # the final server bundle, generated by server/bundler
```

Roughly speaking, that process is this:

1- the code from each `/.owndir/` folder in the target directory-tree will be **assembled** into a single js package, which is placed in `build/<hash>/package/`

2- For each of `client` and `server`, 
  - the **assembled package** will be imported by a **platform package** that provides an entry-point and any platform-specific functionality.
  - the **platform package** will be bundled into a single `dist.js` which can be imported and executed 

# Assemble

This is the process of **assembling** the `.owndir` code from the target directly into a single module, which will be imported by both the server and the client. This step is done only once, unlike **bundling** which must be done twice - once for the client, once for the server.

most relevant files: 
- `src/build/assemble.js`
- `assets/owndir-prefix.js`

## process outline:

1- establish a "package build directory", which will contain all generated artifacts, `build/<hash>/package/`
2- each directory in the target tree which has a `.owndir` will be treated as a package, and copied into `build/<hash>/package/dependencies/<unique_dep_id>`
3- a `package.json` is generated, which imports these packages as dependencies
4- a "master" `index.js` is generated, which imports each of these packages and binds them together into an inheritance heirarchy and exposes the result.

There's some quibbling and details, but that's the broad strokes. The result is a ingle **assembled package**, which exposes the code representation of the target directory-tree.

The "master" `index.js` looks like this:

```
/* 
  first, a fixed prefix, found in assets/owndir-prefix.js
  wherein we: 
    - establish an index of the necessary owdir directory modules
        this index is initially empty, but will shortly be populated by generated code
    - export the `OwnDir` function, by which the assembled object can be constructed
*/

    const modules = {}     // hey look, it's the index

    function addModule (path, mod, plugins) {
      /*
      path:    the relative path to the folder, in the target directory tree that we are adding a module for
      mod:     the module representing that folder
      plugins: a list of functions to be applied to `mod` (ie, to decorate it)

      - decorate the module with a variety of members
      - make it the prototypical child of the parent directory's module 
      - apply the provided plugins
      - add it to the `modules` index
      */
    }

    export function OwnDir (path) {
      // given the path to a directory, pull it out of the `modules` object and return it
      // if the module is not found, generate a dummy that descends from the nearest ancestor module
    }


/*
  Then, we append to this common prefix, a list of the imported directories, like so:
*/

import { default as _owndir_0 } from "_owndir_0"

import { default as _owndir_plugins_00_public_index_js_1 } from "/home/ben/central.example/.owndir/plugins/00-public/index.js"

addModule(
  "", 
  _owndir_0, 
  [_owndir_plugins_00_public_index_js_1]
)

// then child directories, so on and so forth

```

# Bundle

most relevant files: 
- `src/build/bundle.js`
- `src/build/yarn-install.js`
- `src/build/defaults/*`

This part of the framework is both extremely load-bearing, and also not properly fleshed out. Thus the documentation is going to ricochet between the general and the specific. A lot of what I can say is just _my first implementation_, and not necessarily representative of the best general pattern or indeed _any_ general pattern.

Starting from the **assembled package**, **Bundle** handles the last mile into platform-specific runnable code. Presently, OwnDir concerns itself with two target platforms: the client and the server. While there are built-in defaults, the root `.owndir` can specify custom bundlers by including them in `.owndir/build/server/` and `.owndir/build/client/`, respectively. If present, these should contain two directories, `/bundler` and `/package`. These will be copied into the `build/<hash>/` directory.


- `<client-or-server>/bundler`
    This is a package that provides a taking two arguments, `bundle(src, dst)`:
      - `src`: path to the target platform's package, ie `build/<hash>/<client-or-server>/package`
          - this will contain a copy of 
      - `dst`: path where to emit the final bundle, ie `build/<hash>/<client-or-server>/dist.js`

    This function owns the bundling mechanism (ie, if you wanted to use `webpack` vs `esbuild`, or you wanted to do some post-processing like minifying the code, this is the place for that).

- `<client-or-server>/package`
    This is a package that provides the overall entrypoint for the platform. 
      client: 
        - require `../../package` as a dependency, to access the **Assembled** package.
          - ie, by putting `{"dependencies": {"owndir.assembled": "../../package"}}` into `package.json`
        - set up a react-router that walks the owndir package hierarchy based on the url path, and renders from wherever that lands
          - NOTICE: this is where the method that a package must provide to show a custom view comes from.
            In my work so far, I've decided that a package can implement `frame`, which 
          - NOTICE: yes, react. This decision IS made in the client bundler, but not in the `/package` portion. It's implicit in the default way that `esbuild` handles `.jsx` files.
        - inject the router into the DOM

      server:
        - require `../../package` as a dependency, to access the **Assembled** package.
        - expose a pass-through. `module.exports = require('owndir.bundle');`

      note: this is being actively refactored. I expect the server package to take ownership of the server-side routing. There is a tight coupling between the server-side routing and the client, and this has lopsided consequences for the build. The client bundler package is doing a LOT of work to meet the server, but the server bundler package is just a passthrough precisely BECAUSE that functionality was baked into the core. Moving it out into the default server package instead makes it more overridable, and makes the relationship between the server and client builds more explicable.

        Example of the weirdness:
          - the client relies on a PLUGIN to inject a route which that serves `index.html`
          - the core inexplicably serves `/@/client.js` (which is the client `dist.js`)
            - why is this not also in the plugin? because the plugin doesn't know anything about `dist.js`, or where it is on disk!
